include "global.tbh"
const LUIS_STAMP="LUIS> "
const LUIS_CR_LF=chr(13)+chr(10)
const LUIS_INIT_SIGNATURE=&hB5A4

dim luis_init_flag as word

declare sub luis_debugprint(byref print_data as string)
declare sub luis_delay_ms(delay as integer)
declare function luis_dot_decimal_to_hex(stored_mac as string) as string

function luis_start() as en_luis_status_codes
	luis_start=EN_LUIS_STATUS_OK
	
	luis_debugprint("---START---")
	
	if wln.enabled = NO then
		wln.csmap=LUIS_BT_CS
		io.num=LUIS_BT_CS
		io.enabled=YES
		wln.dimap=LUIS_BT_DI
		wln.domap=LUIS_BT_DO
		io.num=LUIS_BT_DO
		io.enabled=YES
		wln.clkmap=LUIS_BT_CLK
		io.num=LUIS_BT_CLK
		io.enabled=YES
		io.num=LUIS_BT_RST
		io.enabled=YES
		wln.disable
		
		io.num=LUIS_BT_RST
		io.state=LOW
		luis_delay_ms(1)
		io.state=HIGH
		
		wln.buffrq(5)
		sys.buffalloc()
		
		wln.boot(0)
	else
		luis_debugprint("WA2000 module already enabled")
	end if
	
	if wln.enabled = NO then
		luis_debugprint("WA2000 module failed to start")
		luis_init_flag=0
		luis_start=EN_LUIS_BT_FAILURE
	else
		dim hex_mac as string = luis_dot_decimal_to_hex(bt.mac)
		dim advertise_name as string = BT_NAME + " " + mid(hex_mac,9, 2) + ":" + mid(hex_mac, 11, 2)
		bt.name=advertise_name
		bt.emulation=PL_WLN_BT_EMULATION_MODE_MICROCHIP
		bt.txbuffrq(5)
		bt.rxbuffrq(5)
		sys.buffalloc()
		bt.enable()
	end if
	
	if luis_start=EN_LUIS_STATUS_OK then
		luis_init_flag=LUIS_INIT_SIGNATURE
	end if
	
end function

sub luis_on_bt_event(bt_event as enum pl_bt_events)
	if luis_init_flag<>LUIS_INIT_SIGNATURE or wln.enabled=NO then
		exit sub
	end if
	
	select case bt_event 
	
	case PL_BT_EVENT_CONNECTED:
		luis_debugprint("Device connected")
	case PL_BT_EVENT_DISCONNECTED:
		luis_debugprint("Device disconnected")
	case PL_BT_EVENT_ENABLED:
		luis_debugprint("Bluetooth enabled")
		luis_debugprint("Connect to device named " + bt.name + " from the LUIS mobile app")
		bt.advertise = YES
	case PL_BT_EVENT_DISABLED:
		luis_debugprint("Bluetooth disabled")
		luis_init_flag=0
	end select
end sub

sub luis_on_bt_data_sent()
	
end sub

sub luis_on_bt_overrun()

end sub

sub bt_commit()
	sys.timercountms=0
	while sys.timercountms<100
	wend
'	luis_debugprint(str(bt.txbuffsize))
	
end sub

sub send_html_chunk()
	dim htmlSize, sdfSize as integer
	dim placeholderStart, placeholderEnd as integer
	dim readPointer as dword = 0
	dim chunkSize as dword = 0
	dim htmlBeginSize as dword
	dim replace_str as string= "####"
	
	romfile.open(LUIS_HTML_FILE)
	htmlSize = romfile.size
	romfile.open(LUIS_SETTINGS_FILE)
	sdfSize = romfile.size
	
	
	bt.txclear()
	dim s as string="{\x22type\x22:\x22spa\x22,\x22length\x22:"+lstr(htmlSize + sdfSize - len(replace_str))+"}"
	while bt.txfree - bt.newtxlen < len(s)
         doevents
	wend
	bt.setdata(s)
	bt.send()
	bt_commit()
	
	romfile.open(LUIS_HTML_FILE)
	placeholderStart = romfile.find32(0, replace_str, 0)
	placeholderEnd = placeholderStart + 4
	
	readPointer = 0
	while readPointer < placeholderStart
		chunkSize = 255
		if readPointer + chunkSize > placeholderStart then
			chunkSize = placeholderStart - readPointer
		end if
		s=romfile.getdata(chunkSize)
		while bt.txfree - bt.newtxlen < len(s)
			doevents
		wend
		bt.setdata(s)
		bt.send()
		bt_commit()
		readPointer = romfile.pointer32
	wend
	romfile.open(LUIS_SETTINGS_FILE)
	while romfile.pointer32 < romfile.size
		if bt.txfree>0  then
			s = romfile.getdata(bt.txfree-bt.newtxlen)
			while bt.txfree - bt.newtxlen < len(s)
				doevents
			wend
			bt.setdata(s)
			bt.send()
			bt_commit()
		end if
		doevents
	wend
	romfile.open(LUIS_HTML_FILE)
	romfile.pointer32 = placeholderEnd
	while romfile.pointer32 < romfile.size
		s=romfile.getdata(bt.txfree-bt.newtxlen)
		while bt.txfree - bt.newtxlen < len(s)
			doevents
		wend
		bt.setdata(s)
		bt.send()
		bt_commit()
	wend
	bt.notifysent(0)
end sub

'====================================================================
public sub proc_bt_cmd(byref cmd_str as string)
	dim reply_str as string(LUIS_MAX_BT_RPL_LEN)
	dim x as byte
	dim setting_name as string(STG_MAX_SETTING_NAME_LEN)
	dim index as byte
	dim s2 as string(64)
	dim stg_data as string(32)
	

	dim cs,f,pos as byte
	dim mac_num as word
	dim i as word

	select case left(cmd_str,1)

	case "G": 'get setting --------------------------------------
		setting_name=mid(cmd_str,2,STG_MAX_SETTING_NAME_LEN)
		if setting_name = "OP" then
			send_html_chunk()
			exit sub
		end if
		
		select case stg_sg(setting_name,0,reply_str,EN_STG_GET)
		case EN_STG_STATUS_OK:
			goto reply_ok_have_data
		case EN_STG_STATUS_UNKNOWN:
			goto reply_err
		case EN_STG_STATUS_INVALID_INDEX:
			goto reply_err
		case else:
			goto reply_failed
		end select

	case "S": 'set setting --------------------------------------
		setting_name=mid(cmd_str,2,2)
		stg_data=right(cmd_str,len(cmd_str)-3)
		select case stg_sg(setting_name,0,stg_data,EN_STG_SET)
		case EN_STG_STATUS_OK:
			goto reply_ok_have_data
		case EN_STG_STATUS_INVALID:
			goto reply_err
		case EN_STG_STATUS_INVALID_INDEX:
			goto reply_err
		case EN_STG_STATUS_UNKNOWN:
			goto reply_err
		case else:
			goto reply_failed
		end select
	case "B": 'buzz the device ---------------------------------- OK
		pat.channel=0
		pat.play(LUIS_PAT_BLINK_BOTH_IN_TURNS_FAST,YES)
		goto reply_ok		

	case "I": 'initialize settings --------------------------
		if stg_restore_multiple(EN_STG_INIT_MODE_NORMAL)<>EN_STG_STATUS_OK then goto reply_failed
		goto reply_ok		

	case "E": 'reboot -------------------------------------------
		wln.disable()
		io.num=LUIS_BT_RST
		io.state=LOW
		sys.reboot()
	
	case else
		goto reply_err
	
	end select

reply_rejected:
	reply_str="R"
	goto send

reply_err:
	reply_str="C"
	goto send

reply_failed:
	reply_str="F"
	goto send

reply_ok:
	reply_str="A"
	goto send

reply_ok_have_data:
	reply_str="A"+reply_str
	goto send

send:
	reply_str=chr(2)+reply_str+chr(13) 'add encapsulation
	
	#if EMULATION=0
		bt.setdata(reply_str)
		bt.send
	#else
		sock.setdata(reply_str)
		sock.send
	#endif
	
reply_null:
end sub

function luis_recv_data() as en_luis_status_codes
	dim x,y as byte
	dim bt_cmd_str as string(LUIS_MAX_BT_CMD_LEN)
	luis_recv_data=EN_LUIS_STATUS_OK
	
	if luis_init_flag<>LUIS_INIT_SIGNATURE then
		luis_recv_data=EN_LUIS_STATUS_NOT_STARTED
		exit function
	end if

	bt_cmd_str=bt_cmd_str+bt.getdata(255-len(bt_cmd_str))
	
	x=instr(1,bt_cmd_str,chr(LUIS_STX),1)
	'this will prevent the string to overflow with garbage
	if len(bt_cmd_str)=LUIS_MAX_BT_CMD_LEN then
		y=instr(1,bt_cmd_str,chr(LUIS_CR),1)
		if x=0 or y=0 then
			bt_cmd_str=""
			exit function
		end if
	end if
	
	while x<>0
		'we've got STX
		bt_cmd_str=right(bt_cmd_str,len(bt_cmd_str)+1-x) 'cut out everything to the left of STX
		x=instr(1,bt_cmd_str,chr(LUIS_CR),1) 'look for command end
		if x=0 then exit function
		proc_bt_cmd(mid(bt_cmd_str,2,x-2))
		bt_cmd_str=right(bt_cmd_str,len(bt_cmd_str)-x)
		x=instr(1,bt_cmd_str,chr(LUIS_STX),1)
	wend
end function


sub luis_debugprint(byref print_data as string)
#if LUIS_DEBUG_PRINT
	sys.debugprint(LUIS_STAMP+print_data+LUIS_CR_LF)
#endif
end sub


sub luis_delay_ms(delay as integer)
	sys.timercountms=0
	while sys.timercountms<delay
	wend
end sub

function luis_dot_decimal_to_hex(stored_mac as string) as string
	dim i as integer = 0
	dim startpos as integer = 1
	dim endpos as integer = 0
	dim num as word = ""
	dim hex_mac as string = ""
	
	for i = 0 to 5
		endpos = instr(startpos,stored_mac,".",0)
		num = val(  mid(stored_mac,startpos,  endpos-startpos) )
		if num<>0 then
			hex_mac = hex_mac + right(hex( num ),2) 
		else
			hex_mac = hex_mac + "00"
		end if
		startpos=endpos+1
	next i
	
	luis_dot_decimal_to_hex = hex_mac
end function